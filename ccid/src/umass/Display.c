#include "headfile.h"
#include "Display.h"
#include "global.h"
#include "kernel.h"
#include "lcd_show.h"


//#include "xml.h"
#include <ctype.h>
//#include <memory.h>
//#include "../Hal/LCD.h"


extern unsigned char g_FunType;

//STRU_Private_Key s_RSA_sk;//unsigned char array[20];//

//BYTE bufdata[0x100] _at_ 0x1000;
//BYTE buf_data[0x20] _at_ 0x1125;
#define code    
#define  xdata    
		 
#define LCD_OLED_VGM12864  
const unsigned char code ASCII0816[] = {
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x30,0x00,0x00,0x00,
	0x00,0x10,0x0C,0x06,0x10,0x0C,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x40,0xC0,0x78,0x40,0xC0,0x78,0x40,0x00,0x04,0x3F,0x04,0x04,0x3F,0x04,0x04,0x00,
	0x00,0x70,0x88,0xFC,0x08,0x30,0x00,0x00,0x00,0x18,0x20,0xFF,0x21,0x1E,0x00,0x00,
	0xF0,0x08,0xF0,0x00,0xE0,0x18,0x00,0x00,0x00,0x21,0x1C,0x03,0x1E,0x21,0x1E,0x00,
	0x00,0xF0,0x08,0x88,0x70,0x00,0x00,0x00,0x1E,0x21,0x23,0x24,0x19,0x27,0x21,0x10,
	0x10,0x16,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0xE0,0x18,0x04,0x02,0x00,0x00,0x00,0x00,0x07,0x18,0x20,0x40,0x00,
	0x00,0x02,0x04,0x18,0xE0,0x00,0x00,0x00,0x00,0x40,0x20,0x18,0x07,0x00,0x00,0x00,
	0x40,0x40,0x80,0xF0,0x80,0x40,0x40,0x00,0x02,0x02,0x01,0x0F,0x01,0x02,0x02,0x00,
	0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x1F,0x01,0x01,0x01,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xB0,0x70,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x80,0x60,0x18,0x04,0x00,0x60,0x18,0x06,0x01,0x00,0x00,0x00,
	0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x0F,0x10,0x20,0x20,0x10,0x0F,0x00,
	0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,
	0x00,0x70,0x08,0x08,0x08,0x88,0x70,0x00,0x00,0x30,0x28,0x24,0x22,0x21,0x30,0x00,
	0x00,0x30,0x08,0x88,0x88,0x48,0x30,0x00,0x00,0x18,0x20,0x20,0x20,0x11,0x0E,0x00,
	0x00,0x00,0xC0,0x20,0x10,0xF8,0x00,0x00,0x00,0x07,0x04,0x24,0x24,0x3F,0x24,0x00,
	0x00,0xF8,0x08,0x88,0x88,0x08,0x08,0x00,0x00,0x19,0x21,0x20,0x20,0x11,0x0E,0x00,
	0x00,0xE0,0x10,0x88,0x88,0x18,0x00,0x00,0x00,0x0F,0x11,0x20,0x20,0x11,0x0E,0x00,
	0x00,0x38,0x08,0x08,0xC8,0x38,0x08,0x00,0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00,
	0x00,0x70,0x88,0x08,0x08,0x88,0x70,0x00,0x00,0x1C,0x22,0x21,0x21,0x22,0x1C,0x00,
	0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x00,0x31,0x22,0x22,0x11,0x0F,0x00,
	0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,
	0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x60,0x00,0x00,0x00,0x00,
	0x00,0x00,0x80,0x40,0x20,0x10,0x08,0x00,0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x00,
	0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00,
	0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x20,0x10,0x08,0x04,0x02,0x01,0x00,
	0x00,0x70,0x48,0x08,0x08,0x08,0xF0,0x00,0x00,0x00,0x00,0x30,0x36,0x01,0x00,0x00,
	0xC0,0x30,0xC8,0x28,0xE8,0x10,0xE0,0x00,0x07,0x18,0x27,0x24,0x23,0x14,0x0B,0x00,
	0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20,
	0x08,0xF8,0x88,0x88,0x88,0x70,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x11,0x0E,0x00,
	0xC0,0x30,0x08,0x08,0x08,0x08,0x38,0x00,0x07,0x18,0x20,0x20,0x20,0x10,0x08,0x00,
	0x08,0xF8,0x08,0x08,0x08,0x10,0xE0,0x00,0x20,0x3F,0x20,0x20,0x20,0x10,0x0F,0x00,
	0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x20,0x23,0x20,0x18,0x00,
	0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x00,0x03,0x00,0x00,0x00,
	0xC0,0x30,0x08,0x08,0x08,0x38,0x00,0x00,0x07,0x18,0x20,0x20,0x22,0x1E,0x02,0x00,
	0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x20,0x3F,0x21,0x01,0x01,0x21,0x3F,0x20,
	0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,
	0x00,0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,0x00,
	0x08,0xF8,0x88,0xC0,0x28,0x18,0x08,0x00,0x20,0x3F,0x20,0x01,0x26,0x38,0x20,0x00,
	0x08,0xF8,0x08,0x00,0x00,0x00,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x20,0x30,0x00,
	0x08,0xF8,0xF8,0x00,0xF8,0xF8,0x08,0x00,0x20,0x3F,0x00,0x3F,0x00,0x3F,0x20,0x00,
	0x08,0xF8,0x30,0xC0,0x00,0x08,0xF8,0x08,0x20,0x3F,0x20,0x00,0x07,0x18,0x3F,0x00,
	0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x10,0x20,0x20,0x20,0x10,0x0F,0x00,
	0x08,0xF8,0x08,0x08,0x08,0x08,0xF0,0x00,0x20,0x3F,0x21,0x01,0x01,0x01,0x00,0x00,
	0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x18,0x24,0x24,0x38,0x50,0x4F,0x00,
	0x08,0xF8,0x88,0x88,0x88,0x88,0x70,0x00,0x20,0x3F,0x20,0x00,0x03,0x0C,0x30,0x20,
	0x00,0x70,0x88,0x08,0x08,0x08,0x38,0x00,0x00,0x38,0x20,0x21,0x21,0x22,0x1C,0x00,
	0x18,0x08,0x08,0xF8,0x08,0x08,0x18,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00,
	0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00,
	0x08,0x78,0x88,0x00,0x00,0xC8,0x38,0x08,0x00,0x00,0x07,0x38,0x0E,0x01,0x00,0x00,
	0xF8,0x08,0x00,0xF8,0x00,0x08,0xF8,0x00,0x03,0x3C,0x07,0x00,0x07,0x3C,0x03,0x00,
	0x08,0x18,0x68,0x80,0x80,0x68,0x18,0x08,0x20,0x30,0x2C,0x03,0x03,0x2C,0x30,0x20,
	0x08,0x38,0xC8,0x00,0xC8,0x38,0x08,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00,
	0x10,0x08,0x08,0x08,0xC8,0x38,0x08,0x00,0x20,0x38,0x26,0x21,0x20,0x20,0x18,0x00,
	0x00,0x00,0x00,0xFE,0x02,0x02,0x02,0x00,0x00,0x00,0x00,0x7F,0x40,0x40,0x40,0x00,
	0x00,0x0C,0x30,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x38,0xC0,0x00,
	0x00,0x02,0x02,0x02,0xFE,0x00,0x00,0x00,0x00,0x40,0x40,0x40,0x7F,0x00,0x00,0x00,
	0x00,0x00,0x04,0x02,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
	0x00,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x19,0x24,0x22,0x22,0x22,0x3F,0x20,
	0x08,0xF8,0x00,0x80,0x80,0x00,0x00,0x00,0x00,0x3F,0x11,0x20,0x20,0x11,0x0E,0x00,
	0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x0E,0x11,0x20,0x20,0x20,0x11,0x00,
	0x00,0x00,0x00,0x80,0x80,0x88,0xF8,0x00,0x00,0x0E,0x11,0x20,0x20,0x10,0x3F,0x20,
	0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x22,0x22,0x22,0x22,0x13,0x00,
	0x00,0x80,0x80,0xF0,0x88,0x88,0x88,0x18,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,
	0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x6B,0x94,0x94,0x94,0x93,0x60,0x00,
	0x08,0xF8,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20,
	0x00,0x80,0x98,0x98,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,
	0x00,0x00,0x00,0x80,0x98,0x98,0x00,0x00,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,
	0x08,0xF8,0x00,0x00,0x80,0x80,0x80,0x00,0x20,0x3F,0x24,0x02,0x2D,0x30,0x20,0x00,
	0x00,0x08,0x08,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,
	0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x20,0x3F,0x20,0x00,0x3F,0x20,0x00,0x3F,
	0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20,
	0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00,
	0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x00,0x80,0xFF,0xA1,0x20,0x20,0x11,0x0E,0x00,
	0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x0E,0x11,0x20,0x20,0xA0,0xFF,0x80,
	0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x20,0x20,0x3F,0x21,0x20,0x00,0x01,0x00,
	0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x33,0x24,0x24,0x24,0x24,0x19,0x00,
	0x00,0x80,0x80,0xE0,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x1F,0x20,0x20,0x00,0x00,
	0x80,0x80,0x00,0x00,0x00,0x80,0x80,0x00,0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20,
	0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x00,0x01,0x0E,0x30,0x08,0x06,0x01,0x00,
	0x80,0x80,0x00,0x80,0x00,0x80,0x80,0x80,0x0F,0x30,0x0C,0x03,0x0C,0x30,0x0F,0x00,
	0x00,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x31,0x2E,0x0E,0x31,0x20,0x00,
	0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x80,0x81,0x8E,0x70,0x18,0x06,0x01,0x00,
	0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x21,0x30,0x2C,0x22,0x21,0x30,0x00,
	0x00,0x00,0x00,0x00,0x80,0x7C,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x3F,0x40,0x40,
	0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,
	0x00,0x02,0x02,0x7C,0x80,0x00,0x00,0x00,0x00,0x40,0x40,0x3F,0x00,0x00,0x00,0x00,
	0x00,0x06,0x01,0x01,0x02,0x02,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x80,0xC0,0xE0,0xF0,0xF8,0x80,0x80,0x80,0x01,0x03,0x07,0x0F,0x1F,0x01,0x01,0x01,
};
unsigned char g_linetotal; //总行数
unsigned char g_linecur;   //当前行

#ifndef SUPPORT_N_DISPLAY

unsigned char gb_fontflag = 1; //大小字体切换标志
unsigned char X_Witch;									//字符写入时的宽度
unsigned char Y_Witch;									//字符写入时的高度
unsigned char X_Current; //当前X,Y坐标
unsigned char Y_Current;
unsigned char DIS_NUM_LINE = 0; //单行显示字节数
unsigned char DIS_PAGE_LINE = 0; //每页行数
unsigned char LCD_X_MAX = 0; //屏幕的X轴的物理宽度
unsigned char LCD_Y_MAX = 64;	  //屏幕的Y轴的物理宽度
unsigned char Font_Wrod;


unsigned char Char_Color;
extern BYTE g_Language;
//extern BYTE g_Lang_str[10];

unsigned char g_bLines[DIS_MAX_LINE];// _at_ 0x1080; 


WORD g_tmpl_addr; //模板地址
BYTE g_plain_tag;   //当前处理的tag在g_stTags中的位置
BYTE g_plain_rem; //当前处理的tag剩余的明文长度
WORD g_plain_pos = 0;  //待显示数据在g_bAddData中的位置
extern void API_ReadData(DWORD adwAddr, BYTE * pucBuf,WORD ucLen);

unsigned char code uparr[]=
{0xC0,0x80,0x00,0x00,0x03,0x03,0x03,0x02};
unsigned char code doarr[]=
{0xC0,0xC0,0xC0,0x40,0x03,0x01,0x00,0x00};
void delay_3ms(unsigned char count) //1延时检测按键子程序
{
  unsigned char i,k;
   for(k=count;k>0;k--)
     for(i=40;i>0;i--) //123
	 {
	   	//Key_Detect();
		;
	 }
}

void Clear_LCD(void)
{
    unsigned int i;
    
    //LCD	
    X_Witch=0;								
    Y_Witch=0;									
    X_Current=0; 
    Y_Current=0;
    Font_Wrod=0;								
  //  BMP_Color=0;
  //  Char_Color=0;
      
    g_linetotal=0; 
    g_linecur=0;   
    g_tmpl_addr=0; 
    g_plain_tag=0;   
    g_plain_rem=0; 
    g_plain_pos=0; 
    g_FunType = 0x10;
//	gw_len_xml =0;
    for (i = 0; i < MAX_NUM_AddTOTAL; i++)
    {
        g_bAddData[i]=0x00;
    }

    for (i = 0; i < DIS_MAX_LINE; i++)
    {
        g_bLines[i] = 0;
    }

}

//========================================================================
// 函数: void LCD_Fill(unsigned int Data)
// 描述: 会屏填充以Data的数据至各点中
// 参数: Data   要填充的颜色数据
// 返回: 无
// 备注: 仅在LCD初始化程序当中调用
// 版本:
//      2006/10/15      First version
//		2007/01/09		V1.2 
//========================================================================
void LCD_Fill(unsigned char Data)
{
	unsigned char i,j;
	unsigned char uiTemp;
	uiTemp = LCD_Y_MAX;
	uiTemp = uiTemp>>3;
	for(i=0;i<uiTemp;i++)								//往LCD中填充初始化的显示数据
	{
		APL_LCD_WriteCmd(0xb0+i);
		APL_LCD_WriteCmd(0x10);
		APL_LCD_WriteCmd(0x00);
		for(j=0;j<LCD_X_MAX;j++)
		{
			APL_LCD_WriteByte(Data);
		}
	}
}

void LCD_Init(void)
{
      //if (g_LCDType & FUN_LCD_192)
      if (gb_fontflag == 1)
      {
            APL_LCD_Init_192();
            LCD_X_MAX = 192; //屏幕的X轴的物理宽度
			DIS_NUM_LINE = 24;//24;	  192/16
		    DIS_PAGE_LINE = 4;
      	}
       else
       {
	 //    APL_LCD_Init();
	 //    LCD_X_MAX = 128;//屏幕的X轴的物理宽度
	 //    DIS_NUM_LINE = 16;//24;	  192/16
	 //    DIS_PAGE_LINE = 4;
       	}
	//}
//	LCD_Fill(0x33);
//	LCD_Fill(LCD_INITIAL_COLOR);
}

//========================================================================
// 函数: void FontSet(int Font_NUM,unsigned int Color)
// 描述: 文本字体设置
// 参数: Font_NUM 字体选择,以驱动所带的字库为准
//		 Color  文本颜色,仅作用于自带字库  
// 返回: 无
// 备注: 
// 版本:
//      2006/10/15      First version
//========================================================================
void FontSet(unsigned char Font_NUM,unsigned char Color)
{
	switch(Font_NUM)
	{
		case 0: Font_Wrod = 16;	//ASII字符A
				X_Witch = 8;
				Y_Witch = HANZI_FONT_HIGH;
				Char_Color = Color;
//				Char_TAB = (unsigned char *)(Asii0816 - 32*16); //低32个字符不可显示
		break;
		case 1: Font_Wrod = 6;	//ASII字符B
				X_Witch = 6;
				Y_Witch = HANZI_FONT_HIGH;
				Char_Color = Color;
//				Char_TAB = (unsigned char *)(Asii0608 - (32*6)); //低32个字符不可显示
		break;		
		case 2: Font_Wrod = 32;	//汉字A
				X_Witch = 16;
				Y_Witch = HANZI_FONT_HIGH;
				Char_Color = Color;
//				Char_TAB = (unsigned char *)GB1616;
		break;
		default: break;
	}
}

//字节倒序
#if LCD_SCR_Rev
BYTE B2B(BYTE y)
{
    BYTE x = y;

    x = ((x & 0x55) << 1) | ((x & 0xaa) >> 1);  
    x = ((x & 0x33) << 2) | ((x & 0xcc) >> 2);  
    x = ((x & 0x0f) << 4) | ((x & 0xf0) >> 4);    

    return x;
}
#endif
//在任意位置显示一个点阵
void PutDots(char *p_data)        
{
    unsigned char i,j;

    #if LCD_SCR_Rev
    X_Current -= X_Witch;   //因X轴自动增量，先回指
    p_data += X_Witch * Y_Witch -1; //偏移到末尾
    #endif
    
    for(j=0;j<Y_Witch;j++)
    {
       if((Y_Current+j) < (Dis_Y_MAX/8))
            APL_LCD_WriteCmd(Y_Current+j+0xb0);
		
		
		
       // APL_LCD_WriteCmd(((X_Current&0xf0) >> 4)|0x10);	//设置初始地址 
       // APL_LCD_WriteCmd(X_Current&0x0f);
		
#ifdef  LCD_OLED_VGM12864
		
        APL_LCD_WriteCmd((((X_Current+2)&0xf0) >> 4)|0x10);	//设置初始地址 
        APL_LCD_WriteCmd((X_Current+2)&0x0f);
#else
		
	    APL_LCD_WriteCmd(((X_Current&0xf0) >> 4)|0x10);	//设置初始地址 
        APL_LCD_WriteCmd(X_Current&0x0f);

#endif
		
		
        for(i=0;i<X_Witch;i++)
        { 

            #if LCD_SCR_Rev
            APL_LCD_WriteByte(B2B(*p_data--));
            #else
            if(((X_Current+i) < Dis_X_MAX)&&((Y_Current+j) < (Dis_Y_MAX/8)))
                APL_LCD_WriteByte(*p_data++);
        #endif
        }
    }

    #if LCD_SCR_Rev
    X_Current += X_Witch;
    #endif
}


//========================================================================
// 函数: void ClrScreen(unsigned int Mode)
// 描述: 清屏函数，执行全屏幕清除或填充前景色
// 参数: Mode   0:全屏除屏
//				1:全屏填充前景色
// 返回: 无
// 备注: 
// 版本:
//      2007/01/11      First version
//========================================================================
void ClrScreen(unsigned char Mode)
{
//	if(Mode==0)
		LCD_Fill(LCD_INITIAL_COLOR);
//	else
//		LCD_Fill(BMP_Color);
}
#if 0
void Arrow(char mode)
{
    unsigned char i,j;
    unsigned char x,y;
    char *p_data;

    FontSet(0, 0xff);

    #if LCD_SCR_Rev
    x= 0;
    #else
    x = LCD_X_MAX - 4;
    #endif
    if (mode == 0)
    {
        #if LCD_SCR_Rev
        y= DIS_MAX_YNUM;
        p_data = (char *)doarr;
        #else
        y = 0;
        p_data = (char *)uparr;
        #endif        
    }
    else
    {
        #if LCD_SCR_Rev
        y = 0;
        p_data = (char *)uparr;
        #else
        y = DIS_MAX_YNUM;
        p_data = (char *)doarr;
        #endif
    }

	for(j=0;j<Y_Witch;j++)
	{
	//if((Y_Current+j) < (Dis_Y_MAX/8))
			APL_LCD_WriteCmd(y+j+0xb0);
		APL_LCD_WriteCmd(((x&0xf0) >> 4)|0x10);	//设置初始地址 
		APL_LCD_WriteCmd(x&0x0f);
		for(i=0;i<(X_Witch/2);i++)
		{  
			//if(((X_Current+i) < Dis_X_MAX)&&((Y_Current+j) < (Dis_Y_MAX/8)))
				APL_LCD_WriteByte(*p_data++);
		}
	}
}
#endif

//在任意位置显示一个点阵
//在全屏显示，包括箭头位置，主要用于显示待机等数据
void PutDots_all(char *p_data)        
{
    unsigned char i,j;

    #if LCD_SCR_Rev
    X_Current -= X_Witch;   //因X轴自动增量，先回指
    p_data += X_Witch * Y_Witch -1; //偏移到末尾
    #endif
    
    for(j=0;j<Y_Witch;j++)
    {
        if((Y_Current+j) < (Dis_Y_MAX/8))
            APL_LCD_WriteCmd(Y_Current+j+0xb0);
		
		
        //APL_LCD_WriteCmd(((X_Current&0xf0) >> 4)|0x10);	//设置初始地址 
        //APL_LCD_WriteCmd(X_Current&0x0f);
		
#ifdef  LCD_OLED_VGM12864	  //132*64的屏来驱动128*64的屏，其中偏移2列
		APL_LCD_WriteCmd((((X_Current+2)&0xf0) >> 4)|0x10);	//设置初始地址 
        APL_LCD_WriteCmd((X_Current+2)&0x0f);
#else
        APL_LCD_WriteCmd((((X_Current)&0xf0) >> 4)|0x10);	//设置初始地址 
        APL_LCD_WriteCmd((X_Current)&0x0f);
#endif	
		
		
        for(i=0;i<X_Witch;i++)
        { 

            #if LCD_SCR_Rev
            APL_LCD_WriteByte(B2B(*p_data--));
            #else
            if(((X_Current+i) < (LCD_X_MAX))&&((Y_Current+j) < (Dis_Y_MAX/8)))
                APL_LCD_WriteByte(*p_data++);
        #endif
        }
    }

    #if LCD_SCR_Rev
    X_Current += X_Witch;
    #endif
}
//extern STRU_Private_Key s_RSA_sk;
void APL_GB2Dots_app(unsigned char *GBData, unsigned char *DotsData)
{
    unsigned long pos;
    unsigned char c1=0,c2=0;
    unsigned int c3;
	unsigned char flag = 0;
	
    c1 = *GBData;
    c2 = *(GBData+1);

    c3= (unsigned int)c1<<8|c2;
    if (c3 >=0x00) 
    {	
       // pos =	c3;
      // pos*=Font_Wrod;
		if(c3>=0x80) //汉字
		{
			pos =	c3;
            pos*=Font_Wrod;
			if(c3>=0xFFE0)
			{
			 
				 
				  pos =(long)pos-(long)0x158200; 
			
			}
			else if(c3>=0xFF00)
			{
			 
				  pos =(long)pos-(long)0x157200; 
			
			}
			else if(c3>=0xFE30)
			{
			 
				 
				  pos =(long)pos-(long)0x156000; 
				
			}
			else if(c3>=0xF900)
			{
			 
				 
				  pos =(long)pos-(long)0x14E000; 
				
			}
			
			else if(c3>=0x4E00)
			{
			
				  pos =(long)pos-(long)0x9C000; 
				
			}
			else if(c3 >=0x2010)
			{
				
				flag = 1;
				goto END;	
           }
		   else
		   {
			pos = 0;
		   }
		 APL_ExFlash_ReadData(pos, DotsData, Font_Wrod);
		}
		else //ascii
		{
		   END:
		   if ((c3 < 0x20)||((c3 < 0x2010)&&(flag)) )
            {
                pos = 0;
			//	return;
            }
			else
			{
				if(flag)
				{
				pos = (c3 - 0x2010);
				}
				else
				{
	            pos = (c3 - 0x20);
				}
	            pos *= Font_Wrod;

				if(flag == 0)
				{
				  //pos >>= 1;
				}
	            
			}
            if (Font_Wrod == 32)
            {
                APL_memset(DotsData,0,64);
				if(flag)
				{
				    pos = (long)pos+(long)0x600	;
					APL_memcpy(DotsData, (unsigned char *)&ASCII0816[pos], Font_Wrod); 
				}
				else
				{
				    
					APL_memcpy(DotsData, (unsigned char *) &ASCII0816[pos], 16); 
				}
				
			
				
            }
			else  if(Font_Wrod == 16)
			{
				APL_memset(DotsData,0,64);

				  
			    APL_memcpy(DotsData, (unsigned char *)&ASCII0816[pos], 16); 

			
			}
         

		} 
	
      
     /*   if(c3 <0x80)
        {
            if (Font_Wrod == 32)
            {
                APL_memcpy(&DotsData[8], &DotsData[16], 8); 
            }
            else
            {
                APL_memcpy(&DotsData[16], &DotsData[32], 16); 
                APL_memcpy(&DotsData[32], &DotsData[64], 16); 
                APL_memcpy(&DotsData[48], &DotsData[96], 16); 
            }
        } 
		  if(c3 <0x80)
        {
            if (c3 < 0x20)
            {
                return;
            }

            pos = (c3 - 0x20);
            pos *= Font_Wrod;
            pos >>= 1;

            if (Font_Wrod == 32)
            {
                APL_memcpy(DotsData, &ASCII0816[pos], 16); 
            }
            else
            {
                APL_memcpy(DotsData, &ASCII1632[pos], 64); 
            }
        }*/

    }
		flag = 0;
		
}


//========================================================================
// 函数: void PutString(unsigned char x,unsigned char y,char *p)
// 描述: 在x、y为起始坐标处写入一串标准字符
// 参数: x  X轴坐标     y  Y轴坐标(0~7页)
//		 p  要显示的字符串  
//flag: 0 显示带箭头的数据
//		1 显示全屏数据，包括箭头位置
// 返回: 无
// 备注: 仅能用于自带的ASCII字符串显示
// 版本:
//      2006/10/15      First version
//========================================================================
void PutString_Ex(unsigned char *p, unsigned char len,unsigned char flag)
{
//  BYTE xdata buf[32];
	BYTE xdata putstring_buf[256];
//	BYTE buf[32];
    BYTE i;
    WORD gb;

    if (len == 0)
    {
        return;
    }       

    for (i = 0; i < len; i+=2)
    {	
       //	APL_GB2Dots_app(p, putstring_buf);

		gb=(*p<<8)|*(p+1);	
		if(gb<0x80)
		{
			FontSet(0, 0);	
		}
		else
		{
			FontSet(2, 0);
		}
		APL_GB2Dots_app(p, putstring_buf);

		if(flag)
			PutDots_all(putstring_buf);
		else				
		    PutDots(putstring_buf);

	    p+=2;
				
	    X_Current = NextDots_Column_X_Address(X_Current,X_Witch);
	}
   
/*	for(i=X_Current;i<Dis_X_MAX;i++)
	{  
			APL_LCD_WriteByte(0x00);
	}
	*/
}

unsigned short UnicodeToUTF8(unsigned char *dest, unsigned short * unicode, unsigned char len)
{   
	unsigned int i, outsize = 0;
	for (i = 0; i < len; i++){
		if ((*unicode) >= 0x0000 && (*unicode) <= 0x007f){
			*dest = (BYTE )(*unicode); 
			dest += 1;
			outsize += 1; 
		}else if ((*unicode) >= 0x0080 && (*unicode) <= 0x07ff){ 
			*dest = 0xc0 | ((*unicode )>> 6);        
			dest += 1;
			*dest = 0x80 | ((*unicode) & (0xff >> 2));
			dest += 1;
			outsize += 2;
		}else if ((*unicode) >= 0x0800 && (*unicode) <= 0xffff){
			*dest = 0xe0 | ((*unicode) >> 12);
			dest += 1;
			*dest = 0x80 | ((*unicode) >> 6 & 0x3f);//0x00ff);
			dest += 1;
			*dest = 0x80 | ((*unicode) & (0xff >> 2));
			dest += 1;
			outsize += 3;
		}
		unicode ++;
	} 
	return outsize;
}


//UTF-8 编码转换成Unicode 
// 码,最多支持3个字节的编码，转换成unicode则为2字节编码
//即最多65536个字符
//return 0: fail 
//else return :unicode内码长度
unsigned int  UTF8ToUnicode(unsigned char* source ,unsigned char *des ,unsigned char len)
{
	unsigned int i,j=0,k;
	unsigned int returnlen=0;

	if(!len)
	return 0xFFFF;

	for(i=0;i<len;i+=j)
	{
		j=0;	
		if(*source&0x80)//最高位是1
		{
			j++;
			if(*source&0x40)	j++;
			if(*source&0x20)	j++;		
			if(*source&0x10)			return 0;//检查第4位是否为0.目前仅支持最高3字节编码
			if(j==1) return 0;
			for(k=1;k<j;k++)//检查后续字节是否为10xxxxxx结构
			{	
				if(((*(source+k))&0xc0 )!=0x80)
					{			
						return 0;
					}
			}	
			if(j==3)
			{
				*des = (*source)<<4;
				*des |=  ((*(source+1))&0x3C)>>2;//取中间4位放到目的地址的低四位
				*(des+1) = (*(source+1))<<6;		//取最后2位放到第2字节头
				*(des+1)  |= (*(source+2))&0x3f;//取最后6位放到第2字节尾
			}else if(j==2){
				*des = (*source  & 0x1C)>>2;//0;
				*(des+1) = (*(source+1))&0x3f;//取最后6位放到第1字节尾
				*(des+1) |=  ((*(source))&0x03)<<6;//取最后2位放到第一字节头
			}
			des+=2;
			source += j;
			
			returnlen +=2;
		}else{			
			*des = 0;
			des++;
			*des= *source;		
			des++;		
			source++;
			j=1;	
			returnlen +=2;
		}
	}
	return returnlen;
}

BYTE LCD_Refresh(BYTE start)
{	   

    BYTE xdata buf[0x100];
    BYTE xdata desdata[0x20];
//#define buf     g_ComBuf //(g_bAddData + MAXDISLPAYLEN+ MAXDISLPAYLEN)
//#define desdata  (buf + 0x100)//(buf + 0x100)
    BYTE len,i,j,k;
    unsigned int len_w;
    BYTE num_page;
    DWORD addr;
    WORD pos;
    
    WORD addr_ef;
    WORD addr_df;
    WORD addr_mf;
    WORD addr_fdf;
    	
    if (g_FunType & FUN_LCD)
    {
        #if LCD_SCR_Rev
        X_Current = LCD_X_MAX;    
        Y_Current = DIS_MAX_YNUM;  
        #else
        X_Current = 0;    
        Y_Current = 0;  
        #endif	
        ClrScreen(0);

        num_page = start + DIS_PAGE_LINE;
        if (num_page > g_linetotal)
        {
            num_page = g_linetotal;
        }
    }
   /* else if (g_FunType & FUN_VOICE)
    {
        num_page = 0x20;
		//add by wy 2010 09 27
		return OrganizeDisplayData();
    }
   */
    for (i = start; i < (num_page); i++)
    {
        if (g_bLines[i] & DISFLAG_DATA) //对应附加数据
        {
            pos = 0;            
            for (j = 0; j < i; j++) //计算偏移地址
            {
                if (g_bLines[j] & DISFLAG_DATA)
                {
                    pos += (g_bLines[j] & 0x3F);
                }
            }

            if (g_FunType & FUN_LCD)
            {
				len = g_bLines[i] & 0x3F;
ABC:		for (k= 0; k < 0x20;k+=2)
			{
				if (((g_bAddData[pos +k]==0x00)&&(g_bAddData[pos+k+1]<=0x20))||((g_bAddData[pos +k]==0x30)&&(g_bAddData[pos+k+1]==0x00)))
                {
					if (len == (k+2))				//删除仅包含控制字符的行
					{
						APL_memcpy(g_bLines + i, g_bLines + i + 1, g_linetotal -i);
						g_linetotal--;
						APL_memcpy(g_bAddData + pos, g_bAddData + pos + len, MAXDISLPAYLEN - pos);
						len = g_bLines[i] & 0x3F;
						goto ABC;		/* 循环删除连续多个空行*/
					}
				}
				else
				{
					break;
				}
			}
				PutString_Ex(&g_bAddData[pos], len,0);				
            }						
        }
        else //对应待机等交易提示信息
        {
            //if (g_tmpl_addr == 0)
            //{
            //    return SW6A82;
            //}

            // addr_ef = gw_addr_ef;
            // addr_df = gw_addr_df;
            // addr_fdf = gw_addr_fdf;
            // addr_mf = gw_addr_mf;
                     
           // FS_AlocateFile(g_tmpl_addr);
           // if ( (gs_filehead.type & 0x03) != 0x02) {return SW6985; } //不是变长记录文件
          
           // addr = FS_Seek_TagOfVarRecord(0xEE, 0x00, &len);			//EE记录存放可能出现的xml语种信息
            if (addr == 0)
            {
               // g_Language = 0;
            }
            else
            {
                //g_Language = 0;
                API_ReadData(addr,buf,5);
                len = buf[1]; 
                addr+=2;
                j = 0;
                while(len)
                {
                    API_ReadData(addr,buf,12);
                    len = len-buf[1]-2;
                    addr=addr+buf[1]+2;
                    if ((j == 0) && (buf[0] == 0xEE)) //默认语种
                    {
                       // g_Language = (buf[2] << 6);
                    }
                    j = 1;
                  /*  if (APL_memcmp((void*)g_Lang_str, (void*)(buf + 2), buf[1])== 0)
                    {
                        if (*(g_Lang_str + buf[1]) == 0x22)			//ASCII的引号，检验语种字符串已结束
                        {
                            g_Language = (buf [0]<<6);
                            break;
                        }
                    }
					*/
                }
            }
			
           // addr = FS_Seek_TagOfVarRecord((g_Language|g_bLines[i]), 0x00, &len);

            // gw_addr_ef = addr_ef;
            // gw_addr_df = addr_df;
           //  gw_addr_fdf = addr_fdf;
            // gw_addr_mf = addr_mf;
             
            if (addr == 0)
            {
                goto A;
            }

            API_ReadData(addr,buf,5);
          //Get length 数据存储TLV 格式
          len = buf[1];

          if (len < 1) //错误的项
          {
          	 goto A;
          }   
          
//		 API_ReadData(addr + 2 , buf, len);
		  API_ReadData(addr + 2 ,buf,len);
/*
		  len_w = UTF8ToUnicode(buf,desdata,len);	
   			 
			 //检查每个TAG的长度
			 k=0;
			 while(j<len_w)
			 {
				 if((desdata[j]==0x00)&&(!((desdata[j+1])&0x80)))//英文
				 {k++;}
				 else
				 {k+=2;}
				 j+=2;
				 if(k==DIS_NUM_LINE+1)
				 {
					len_w =j ;
					break;
				 }
				 else if(k==(DIS_NUM_LINE))
				 {
					if((desdata[j]==0x00)&&(!((desdata[j+1])&0x80)))//英文
					{
						len_w =j +2;
					}
					break;
				 }
			 }
	*/	 
           //if (g_FunType & FUN_LCD)
           // {      
                //  PutString_Ex(buf, len * 3,1);         
           // }
	
       }
A:
        if (g_FunType & FUN_LCD)
        {
            #if LCD_SCR_Rev
            Y_Current -= 2;
            X_Current = LCD_X_MAX; 
            #else
            Y_Current = NextDots_Line_Y_Address(Y_Current);
            X_Current = 0;
            #endif
        }
    }
/*
    if (g_FunType & FUN_LCD)
    {
        if (start > 0)
        {
            Arrow(0);
        }
        if (i < g_linetotal)
        {
            Arrow(1);
        }
    }
    */
#undef buf
#undef desdata
//enable_int(INTC_TMU0);

return 0;

}

//暂时支持65536以下的ASCII数字字串转换成0x0~0xFFFF间的16进制数
//len为ASCII字串的长度
//如输入buf为"13579"(即0x31,0x33,0x35,0x37,0x39),则len为5,输出为"0x350B"
unsigned short DecToHexa(unsigned char * buf, unsigned char len)
{
	unsigned char i, array[5];
	unsigned int tmp = 0;
	for (i = 0; i < 5; i++)
		array[i] = 0;
	for (i= 0; i < len; i++)
		array[5 -1 -i] = buf[len -1 - i]-'0';
	for (i = 0; i < 5; i++){
		if (i==4)
			if (tmp > 6553)
				if (array[4]> 5)
					return 0;
		tmp = tmp * 10 + array[i];
	}
	return tmp;
}

unsigned int HexToHexa(unsigned char * buf, unsigned char len)
{
	unsigned char i, array[4];
	unsigned int tmp = 0;
	for (i = 0; i < 4; i++)
		array[i] = 0;
	for (i= 0; i < len; i++){
		array[4 -1 -i] = buf[len -1 - i];
		if ((array[4 -1 -i]>='0')&&(array[4 -1 -i]<='9'))
			array[4 -1 -i] -= '0';
		if ((array[4 -1 -i]>='A')&&(array[4 -1 -i]<='Z'))
			array[4 -1 -i] -= '7';
		if ((array[4 -1 -i]>='a')&&(array[4 -1 -i]<='z'))
			array[4 -1 -i] -= 'W';
	}
	tmp = (array[0]<<12) + (array[1]<<8) +(array[2]<<4)+ array[3];
	return tmp;
}

code unsigned char ESC_Char[8][6] = {
	{0x05, 0x04, 0x04, 0x06, 0x06, 0x02},	//六种转义字符的strlen
	{'&', '<', '>', 0x27, 0x22},				//	"&", "<", ">", " ' ", " " "
	{0x26, 0x61, 0x6D, 0x70, 0x3B, 0x00},	//  "  &amp; "  
	{0x26, 0x6C, 0x74, 0x3B, 0x00, 0x00},	//  "    &lt;   "  
	{0x26, 0x67, 0x74, 0x3B, 0x00, 0x00},	//  "   &gt;   "  
	{0x26, 0x61, 0x70, 0x6F, 0x73, 0x3B},	//  " &apos; "  
	{0x26, 0x71, 0x75, 0x6F, 0x74, 0x3B},	//  " &quot; "  
	{0x26, 0x23, 0x00, 0x00, 0x00, 0x00}		//  "    &#    "  
};	//前五种是xml转义字符，最后一种是unicode转义字符，具体形式为&#9999或&#xffff


//unsigned short FindStringInBufFromBack (unsigned char* pbuffer, unsigned char* search, unsigned short buffersize);
//unsigned short FindStringInBuf (unsigned char* pbuffer, char* search, unsigned short buffersize);

//将UTF-8编码的字串中的xml转义字符，unicode转义字符替换为正常字符
//返回-1表示unicode转义字符不符合规范，返回其它值表示替换后字符串的新长度
unsigned short ESC_Char_Replace(unsigned char * buf, unsigned int len)	
{
#if 0
	unsigned char i,j;
	unsigned short tmp1;
	unsigned short tmp,backup_len;
	
	 //unsigned int unicode;

	unsigned short unicode;

	backup_len = len;
	while(1){
		tmp = FindStringInBufFromBack(buf, (unsigned char *)"&", len);
		if(ISNEG(tmp))
			break;
		len = tmp - 1;
		for (i = 0; i < 7; i++){
			if (i == 6)return GETNEG(1);		//找到了&符，却没有匹配任何一种转义字符
			if ( 0 == APL_memcmp(buf + tmp, ESC_Char[i + 2],  ESC_Char[0][i])){
				if (i == 5){		/* 替换&#  */
					tmp1 = FindStringInBuf(buf + tmp + 2, ";", 6);
					if(ISNEG(tmp1))	/* &# 后没有; */
						return GETNEG(1);		
					if (('x' == buf[tmp + 2])||('X' == buf[tmp + 2])){
						for (j = 1; j < tmp1; j++){		//&#x和;之间不是0~F的数字
							if (isxdigit(*(buf + tmp + 2 + j))== 0)
								return GETNEG(1);
						}
						unicode = HexToHexa(buf + tmp + 3, tmp1 -1);
					}else if ((buf[tmp + 2]>= '0')&&(buf[tmp + 2]<='9')){
						for (j = 0; j < tmp1; j++){		//&#和;之间不是0~9的数字
							if (isdigit(*(buf + tmp + 2 + j))== 0)
								return GETNEG(1);
						}
						unicode = DecToHexa(buf + tmp + 2,tmp1);
						if (unicode == 0)	//&#后跟的十进制数大于0xFFFF了
							return GETNEG(1);
					}
					else
						return GETNEG(1);
					j = UnicodeToUTF8( buf + tmp,&unicode, 1);
					APL_memcpy(buf + tmp + j, buf + tmp + tmp1 + 2 +1, backup_len - tmp - tmp1-1);
					backup_len = backup_len -3 -(tmp1 -j);
				}else{				/* 替换其它5种*/
					buf[tmp] = ESC_Char[1][i];
					APL_memcpy(buf + tmp + 1, buf + tmp + ESC_Char[0][i], backup_len - tmp);
					backup_len = backup_len -ESC_Char[0][i] + 1;
				}
				break;
			}
		}
	}
	return backup_len;
#endif 
 	return 0;
}

//组织显示数据
//pBuf 为输入的utf-8汉字编码，
//blen为输入数据长度
//extern BYTE xdata g_DispSeal;
unsigned char Make_DisData(unsigned char *pBuf, unsigned char bLen)
{
    WORD i = 0,j=0,k=0;
	static WORD backup_j = 0;
	unsigned int len_w,tmp;
	BYTE *pData;
	//BYTE temp = 0;
	//unsigned short temp = 0;
	//BYTE sum = 0;
//	BYTE xdata desdata[MAX_NUM_AddTOTAL];
if (g_FunType & FUN_LCD)   
{
	pData = &g_bAddData[g_plain_pos];
	tmp = ESC_Char_Replace(pBuf, bLen);	
    
	//if(ISNEG(tmp))
	//	return 3;
	len_w = UTF8ToUnicode(pBuf, pData,bLen);
	if (len_w == 0xFFFF)  return 5;
	if (len_w == 0)			//UTF-8解码错误
		return 2;
	 if( (g_plain_pos+len_w) > (MAX_NUM_AddTOTAL-1))
    {
        return 1;
    }
	/*if(g_DispSeal&&(len_w > DIS_NUM_LINE*2))
	{
	temp = DIS_NUM_LINE - backup_j;
	sum  = (g_bLines[g_plain_tag-1]&0x3F)+temp*2;
	g_bLines[g_plain_tag-1]	=  sum|DISFLAG_DATA;
	len_w -= temp*2;
	g_plain_pos += temp*2;
	backup_j = DIS_NUM_LINE;
	}*/

	//APL_memcpy(&g_bAddData[g_plain_pos], desdata, len_w);
	g_plain_pos += len_w;   
	
	i=0;
	while(i < len_w)
    {
         if (g_plain_tag > DIS_MAX_LINE-1)
        {
            break;
        }        
		if(i==(len_w-1))
			break;
		
		if((pData[i]==0x00)&&(!((pData[i+1])&0x80)))//英文字符或数字unicode 00000000 0xxxxxxx
		{			
			j++;
		}else//汉字等
		{
			j+=2;	
		}
		i+=2;		
		k++;		
		
		if((j==DIS_NUM_LINE)||(j==(DIS_NUM_LINE-1))||(i==len_w))//到行最后一个字符
		{	
			if (i==len_w)
			{
				;
			}
			else if (j==(DIS_NUM_LINE-1))
			{
				if((pData[i]==0x00)&&(!((pData[i+1])&0x80)))//英文字符或数字unicode 00000000 0xxxxxxx
				{
						k++;
						i+=2;
						j++;
				}
			}
	//		print_BYTE(0xff);
		//	print_BYTE(g_DispSeal);
		/*	if (g_DispSeal &&((j + backup_j)< DIS_NUM_LINE + 1))
			{
				g_bLines[g_plain_tag - 1] += k*2;
			//	print_BYTE(0xfe);
			//	print_WORD(backup_j);
			//	print_BYTE(g_bLines[g_plain_tag - 1]);
				
			}
			else
			{
				g_bLines[g_plain_tag] = k*2|DISFLAG_DATA;//最大为30个字节
			//	print_BYTE(0xfd);
			//	print_WORD(backup_j);
			//	print_BYTE(g_bLines[g_plain_tag]);
				g_plain_tag++;
				
			}
			*/
		//	print_BYTE(0xfc);
		//	print_WORD(j);
			backup_j = j;
			k=j=0;
		}	    
    }
	
}
	return 0;
}

//显示数据分页等处理
//计算需要显示的总行数
void Process_DisData(void)
{
    WORD i = 0;
    BYTE k = 0;
	if (g_FunType & FUN_LCD)   
	{
	    for (i = 0; i < DIS_MAX_LINE; i++)
	    {
	    	if(g_bLines[i]&DISFLAG_DATA)
			k++;		
	    }  
	  
	    g_linetotal = k;
	}

}

void LCD_display_UTF8(unsigned char *buf,unsigned char len)
{
	Clear_LCD();
	Make_DisData(buf, len);
	Process_DisData();
	LCD_Refresh(0);
}
// *** 显示相关交易信息*** //
/* Stype:  1，  交易成功
 *             2，  交易取消
 *             0 及其他值时显示待机屏幕
 ************************************/
extern BYTE g_Language;
void LCD_Scr_W(BYTE Stype)
{
 	BYTE i;
    Clear_LCD();
	
   // g_tmpl_addr = FS_SearchSonFID(0xEEEE, 0x02, gw_addr_mf);

     if (g_tmpl_addr == 0)
     {
         if(g_FunType&FUN_LCD)
         { 
         	ClrScreen(0);
		 }
            return;
     }
        
        g_linecur = 0;
        g_linetotal = DIS_MAX_TOTAL_LINE;

		switch(Stype) {
			case 1://交易确认
			for(i=0;i<DIS_MAX_TOTAL_LINE;i++)
			{
				 g_bLines[i]= i+W_PIC1;
			}
				break;
			case 2://交易取消
			for(i=0;i<DIS_MAX_TOTAL_LINE;i++)
			{
				 g_bLines[i]= i+W_PIC2;
			}
                		break;
			case 3://xml解析有误，不予签名
			for(i=0;i<DIS_MAX_TOTAL_LINE;i++)
			{
				 g_bLines[i]= i+W_PIC3;
			}
				break;
			case 4://交易超时
			for(i=0;i<DIS_MAX_TOTAL_LINE;i++)
			{
				 g_bLines[i]= i+W_PIC4;
			}
                		break;	
			case 5://再次确认
			for(i=0;i<DIS_MAX_TOTAL_LINE;i++)
			{
				 g_bLines[i]= i+W_PIC5;
			}
                		break;		                		
			case 0: //待机屏幕
			default:
			for(i=0;i<DIS_MAX_TOTAL_LINE;i++)
			{
				 g_bLines[i]= i+W_PIC0;
			}
				break;
		}
		if (g_FunType & FUN_LCD)
        	LCD_Refresh(0);

}

#if 0
void APP_KeyProcess_Hook(BYTE bNum)
{
    if(key_flag==1)
    {
	    if (bNum == 0) //Up
	    {
	        if (g_FunType & FUN_LCD)
	        {
	            if (g_linecur)
	            {
	                g_linecur--;
	                LCD_Refresh(g_linecur);
	            }     
	        }

			if(g_FunType & FUN_VOICE)
			{			      
		        key_cancel=0;
			 	LCD_Refresh(0);		
                      //key_cancel=0;                
			}	
	    }
	    else if (bNum == 1) //Down
	    {
	        if (g_FunType & FUN_LCD)
	        {
	            if (g_linetotal)
	            {
        	            if (g_linecur + DIS_MAX_TOTAL_LINE < g_linetotal )//zzg 4 -> 2
        	            {
        	                g_linecur++;
        	                LCD_Refresh(g_linecur);
        	            }  
	            }
	        }

	   /*     if(g_FunType & FUN_VOICE)
		{
			key_cancel=1;
		}	*/
	    }
	    else if (bNum == 2) //OK
	    {	       
	            key_cancel=0;
                    LCD_Scr_W(1);   
                    key_flag = 2;	 
	    }
	    else if (bNum == 3) //Cancle
	    {
	          key_cancel=0;
                LCD_Scr_W(2);	        
    	         key_flag = 3;         
            }    

    	}
}
#endif

void APP_ShowInit(void)
{
  LCD_Scr_W(0);
}

#endif
WORD ipt_card_APDU(BYTE *cmd, WORD len, BYTE *res)
{
	unsigned short int i;
	unsigned char resLen = 0;
	UsbBulkMsgBuf[0] =0x6f;
	UsbBulkMsgBuf[1] =len;
	UsbBulkMsgBuf[2] =0x00;
	UsbBulkMsgBuf[3] =0x00;
	UsbBulkMsgBuf[4] =0x00;
	UsbBulkMsgBuf[5] =0x00;
	UsbBulkMsgBuf[6] =0x00;
	UsbBulkMsgBuf[7] =0x00;
	UsbBulkMsgBuf[8] =0x00;
	UsbBulkMsgBuf[9] =0x00;
	for(i=0;i<len;i++)
	{
		UsbBulkMsgBuf[10+i] =cmd[i];
		
	}
    //led4_on();
   // PC_to_RDR_IccPowerOn();
	//ISO14443_carrier_on();
	CCID_AnalyseBulkMessage();
    //led4_off();
	resLen = UsbBulkInMsgBuf[1]+(UsbBulkInMsgBuf[2]<<8);
	memcpy(res,&UsbBulkInMsgBuf[10],resLen);
	/*
	UsbBulkMsgBuf[10] =0x00;
	UsbBulkMsgBuf[11] =0xa4;
	UsbBulkMsgBuf[12] =0x00;
	UsbBulkMsgBuf[13] =0x00;
	UsbBulkMsgBuf[14] =0x02;
	UsbBulkMsgBuf[15] =0x3f;
	UsbBulkMsgBuf[16] =0x00;
	*
	
	*/
	return resLen;
}

BYTE ipt_card_Reset(BYTE *res)
{
    //ISO14443_carrier_on();
    //slot1 =1;
	card_type =0x0a;
	UsbBulkMsgBuf[0] =0x62;
	UsbBulkMsgBuf[1] =0x00;
	UsbBulkMsgBuf[2] =0x00;
	UsbBulkMsgBuf[3] =0x00;
	UsbBulkMsgBuf[4] =0x00;
	UsbBulkMsgBuf[5] =0x00;
	UsbBulkMsgBuf[6] =0x00;
	UsbBulkMsgBuf[7] =0x00;
	UsbBulkMsgBuf[8] =0x00;
	UsbBulkMsgBuf[9] =0x00;
	CCID_AnalyseBulkMessage();
    return 1;
    
}
void LCD_ClearLine(unsigned char line1)
{
    BYTE i, j;

    line1 &= 0x1F;
    line1 <<= 1;
    for (j = 0; j < 2; j++)
    {
        APL_LCD_WriteCmd(line1 + 0xb0);
        APL_LCD_WriteCmd(0x10);	//设置初始地址 
        APL_LCD_WriteCmd(0x00);
        for (i = 0; i < LCD_X_MAX; i++)
        { 
            APL_LCD_WriteByte(0);
        }
        line1++;
    }    
}
unsigned char api_GetKey_OTP(void)
{
	return 0; 
}
unsigned char api_GetKey_noBlock(void)
{
	return 0;
}
unsigned char api_GetKey(void)
{
	return 0;
}
void LCD_display_UTF8Line_ForAsc(unsigned char *buf,unsigned char len, unsigned char linet)
{
	BYTE flag;

	if (linet & 0x80)
	{
		flag = 0x80;
	}
	else
	{
		flag = 0x00;
	}    

	if ((linet & 0x1F) > 3)
	{
		return;

	}

	if (linet & 0x40) //需要先清除该行
	{
		LCD_ClearLine(linet);
	}

	linet &= 0x1F;

	Y_Current = (linet << 1);
	X_Current = 0;
	PutString_Ex(buf, len, flag);	
}
void LCD_display_UTF8Line(unsigned char *buf,unsigned char len, unsigned char linet)
{
    BYTE flag, buf_unicode[48];
    WORD len_w;

    if (linet & 0x80)
    {
        flag = 0x80;
    }
    else
    {
        flag = 0x00;
    }    

    if ((linet & 0x1F) > 3)
    {
        return;

    }

    if (linet & 0x40) //需要先清除该行
    {
        LCD_ClearLine(linet);
    }

    linet &= 0x1F;
    
    Y_Current = (linet << 1);
    X_Current = 0;

    len_w = UTF8ToUnicode(buf, buf_unicode, len);
    PutString_Ex(buf_unicode, len_w, flag);	
}


extern void  CheckLowPower(void);

extern  void ShowCharsLine(const unsigned char (* ptr)[16],int index,int len);

const unsigned char MagCard[12][16]=
{

{0x40,0x42,0xCC,0x00,0x00,0x44,0x54,0x54,0x54,0x7F,0x54,0x54,0x54,0x44,0x40,0x00},
{0x00,0x00,0x7F,0x20,0x10,0x00,0xFF,0x15,0x15,0x15,0x55,0x95,0x7F,0x00,0x00,0x00},
{0x00,0x00,0xFE,0x12,0x12,0x12,0xF2,0x12,0x12,0x1E,0x00,0xF0,0x00,0x00,0xFF,0x00},
{0x10,0x0E,0x01,0x3F,0x01,0x01,0xFF,0x11,0x21,0x1F,0x00,0x0F,0x40,0x80,0x7F,0x00},
{0x84,0xE4,0x5C,0xC4,0x00,0x08,0xC8,0x39,0x8E,0x08,0x08,0xCC,0x3B,0x88,0x08,0x00},
{0x00,0x3F,0x10,0x3F,0x00,0x63,0x5A,0x46,0xE1,0x00,0x63,0x5A,0x46,0xE1,0x00,0x00},
{0x80,0x90,0x90,0x48,0x4C,0x57,0x24,0xE4,0x24,0x54,0x4C,0x44,0x80,0x80,0x80,0x00},
{0x00,0x42,0x22,0x12,0x0A,0x42,0x82,0x7F,0x02,0x02,0x0A,0x12,0x22,0x42,0x00,0x00},
{0x40,0x40,0x40,0x40,0x40,0x40,0xFF,0x44,0x44,0x44,0x44,0x44,0x44,0x40,0x40,0x00},
{0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x02,0x04,0x08,0x10,0x00,0x00,0x00},

//省略号
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x30,0x30},



};



void ShowMagCard(void)
{

   unsigned char DataShow[] = {0xE8,0xAF,0xB7,0xE5,0x88,0xB7,0xE7,0xA3,0x81,0xE6,0x9D,0xA1,0xE5,0x8D,0xA1,0x2E,0x2E,0x2E};
   //unsigned char DataShow2[] = {0x2E,0,0x2E,0,0x2E,0x2E,0x2E,0x2E};	   //unicode 为 0x2E，0x00     ASC 为0x2E
   LCD_BackLight_On();
   ShowLcdOnePicture(MAG);

 #ifdef LIB2M
   LCD_display_UTF8Line(DataShow,18,3);
   //LCD_display_UTF8Line(DataShow2,8,1);
 #else
	ShowCharsLine(MagCard,0,6);
 #endif

}


unsigned int showBLdelay;
void ShowDefault(void)
{
   
	  //LCD_Fill(0x00);
	  ShowLcdOnePicture(DEFAULT);
	  CheckLowPower();
	  //LCD_BackLight_Off();
	  //	beep_con();
	  showBLdelay=5000;
	  
}





const unsigned char ContectlessCard[8][16]=
{
	{0x40,0x42,0xCC,0x00,0x00,0x44,0x54,0x54,0x54,0x7F,0x54,0x54,0x54,0x44,0x40,0x00},
	{0x00,0x00,0x7F,0x20,0x10,0x00,0xFF,0x15,0x15,0x15,0x55,0x95,0x7F,0x00,0x00,0x00},/*"请",0*/
	{0x10,0x10,0x10,0xFF,0x10,0x98,0x26,0x22,0xE2,0x3A,0xA2,0x22,0x22,0x2A,0x06,0x00},
	{0x04,0x44,0x82,0x7F,0x01,0x10,0x10,0x13,0x12,0x12,0xFF,0x12,0x12,0x12,0x10,0x00},/*"挥",1*/
	{0x40,0x40,0x40,0x40,0x40,0x40,0xFF,0x44,0x44,0x44,0x44,0x44,0x44,0x40,0x40,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x02,0x04,0x08,0x10,0x00,0x00,0x00},/*"卡",2*/
	 //省略号
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x30,0x30}
};


void ShowContectlessCard(void)
{

   unsigned char DataShow[] = {0xE8,0xAF,0xB7,0xE6,0x8C,0xA5,0xE5,0x8D,0xA1,0x2E,0x2E,0x2E};
   LCD_BackLight_On();
   ShowLcdOnePicture(CONTL);

#ifdef LIB2M
   	 LCD_display_UTF8Line(DataShow,12,3);
#else
  		ShowCharsLine(ContectlessCard,0,4);
#endif

}


const unsigned char Finger[10][16]=
{
	{0x40,0x42,0xCC,0x00,0x00,0x44,0x54,0x54,0x54,0x7F,0x54,0x54,0x54,0x44,0x40,0x00},
	{0x00,0x00,0x7F,0x20,0x10,0x00,0xFF,0x15,0x15,0x15,0x55,0x95,0x7F,0x00,0x00,0x00},/*"请",0*/
	{0x10,0x10,0x10,0xFF,0x90,0x20,0x98,0x88,0x88,0xE9,0x8E,0x88,0x88,0xA8,0x98,0x00},
	{0x02,0x42,0x81,0x7F,0x00,0x00,0x80,0x84,0x4B,0x28,0x10,0x28,0x47,0x80,0x00,0x00},/*"按",1*/
	{0x10,0x10,0x10,0xFF,0x10,0x90,0x00,0x3F,0x48,0x48,0x44,0x44,0x44,0x42,0x70,0x00},
	{0x04,0x44,0x82,0x7F,0x01,0x00,0x00,0xFF,0x49,0x49,0x49,0x49,0x49,0xFF,0x00,0x00},/*"指",2*/
	{0x20,0x30,0xAC,0x63,0x10,0x08,0x08,0xF8,0x09,0x0E,0x08,0xF8,0x08,0x08,0x00,0x00},
	{0x22,0x67,0x22,0x12,0x92,0x80,0x40,0x21,0x16,0x08,0x16,0x21,0x40,0x80,0x80,0x00},/*"纹",3*/
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x30,0x30}
};

void ShowFinger(void)
{

   unsigned char DataShow[] = {0xE8 ,0xAF ,0xB7 ,0xE6 ,0x8C ,0x89 ,0xE6 ,0x8C ,0x87 ,0xE7 ,0xBA ,0xB9 ,0x2E ,0x2E ,0x2E};
   LCD_BackLight_On();
   ShowLcdOnePicture(FINGER);

#ifdef LIB2M
   LCD_display_UTF8Line(DataShow,15,3);
#else
   	ShowCharsLine(Finger,0,5);
#endif

}


const unsigned char ContectCard[8][16]=
{

	{0x40,0x42,0xCC,0x00,0x00,0x44,0x54,0x54,0x54,0x7F,0x54,0x54,0x54,0x44,0x40,0x00},
	{0x00,0x00,0x7F,0x20,0x10,0x00,0xFF,0x15,0x15,0x15,0x55,0x95,0x7F,0x00,0x00,0x00},/*"请",0*/
	{0x10,0x10,0xFF,0x10,0xB0,0x24,0x24,0xA4,0x24,0xFC,0x22,0x22,0x23,0x22,0x20,0x00},
	{0x42,0x82,0x7F,0x01,0x00,0xFF,0x49,0x48,0x40,0x7F,0x40,0x49,0x49,0xFF,0x00,0x00},/*"插",1*/
	{0x40,0x40,0x40,0x40,0x40,0x40,0xFF,0x44,0x44,0x44,0x44,0x44,0x44,0x40,0x40,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x02,0x04,0x08,0x10,0x00,0x00,0x00},/*"卡",2*/
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x30,0x30}

};



void ShowContectCard(void)
{

   unsigned char DataShow[] = {0xE8,0xAF,0xB7,0xE6,0x8F,0x92,0xE5,0x85,0xA5,0xE5,0x8D,0xA1,0x2E,0x2E,0x2E};
   LCD_BackLight_On();
   ShowLcdOnePicture(CONT);

#ifdef LIB2M
   LCD_display_UTF8Line(DataShow,15,3);
#else
   	ShowCharsLine(ContectCard,0,4);
#endif

}


const unsigned char IDCard[12][16]=
{
	{0x40,0x42,0xCC,0x00,0x00,0x44,0x54,0x54,0x54,0x7F,0x54,0x54,0x54,0x44,0x40,0x00},
	{0x00,0x00,0x7F,0x20,0x10,0x00,0xFF,0x15,0x15,0x15,0x55,0x95,0x7F,0x00,0x00,0x00},/*"请",0*/
	{0x08,0x08,0xF9,0x4A,0x48,0xC8,0x48,0x20,0xD8,0x17,0x10,0x10,0xF0,0x10,0x10,0x00},
	{0x40,0x30,0x0F,0x20,0x40,0x3F,0x80,0x40,0x21,0x16,0x08,0x16,0x21,0x40,0x80,0x00},/*"放",1*/
	{0x00,0x00,0x00,0xFC,0x54,0x56,0x55,0x54,0x54,0x54,0x54,0xFC,0x00,0x80,0x40,0x00},
	{0x40,0x42,0x42,0x23,0x22,0x22,0x12,0x12,0x0A,0x46,0x82,0x7F,0x01,0x00,0x00,0x00},/*"身",2*/
	{0x00,0x80,0x60,0xF8,0x07,0x80,0x40,0xB0,0x8E,0x80,0x80,0x87,0x98,0x60,0x80,0x00},
	{0x01,0x00,0x00,0xFF,0x00,0x80,0x40,0x30,0x0F,0x00,0x40,0x80,0x7F,0x00,0x00,0x00},/*"份",3*/
	{0x40,0x40,0x42,0xCC,0x00,0x00,0x04,0xC4,0x04,0x04,0xFC,0x04,0x04,0x04,0x04,0x00},
	{0x00,0x00,0x00,0x3F,0x10,0x48,0x40,0x7F,0x40,0x40,0x7F,0x41,0x41,0x41,0x40,0x00},/*"证",4*/
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x30,0x30}
};





void ShowIDCard(void)
{

   unsigned char DataShow[] = {0xE8,0xAF,0xB7,0xE6,0x94,0xBE,0xE8,0xBA,0xAB,0xE4,0xBB,0xBD,0xE8,0xAF,0x81,0x2E,0x2E,0x2E};
   LCD_BackLight_On();

   ShowLcdOnePicture(PSEC);

#ifdef LIB2M
   LCD_display_UTF8Line(DataShow,18,3);
#else
   ShowCharsLine(IDCard,0,6);
#endif

}



const unsigned char KeyPad[8][16]=
{
	{0x40,0x42,0xCC,0x00,0x00,0x44,0x54,0x54,0x54,0x7F,0x54,0x54,0x54,0x44,0x40,0x00},
	{0x00,0x00,0x7F,0x20,0x10,0x00,0xFF,0x15,0x15,0x15,0x55,0x95,0x7F,0x00,0x00,0x00},/*"请",0*/
	{0x10,0x10,0x10,0xFF,0x90,0x20,0x98,0x88,0x88,0xE9,0x8E,0x88,0x88,0xA8,0x98,0x00},
	{0x02,0x42,0x81,0x7F,0x00,0x00,0x80,0x84,0x4B,0x28,0x10,0x28,0x47,0x80,0x00,0x00},/*"按",1*/
	{0x40,0x30,0xEF,0x24,0x24,0x80,0xE4,0x9C,0x10,0x54,0x54,0xFF,0x54,0x7C,0x10,0x00},
	{0x01,0x01,0x7F,0x21,0x51,0x26,0x18,0x27,0x44,0x45,0x45,0x5F,0x45,0x45,0x44,0x00},/*"键",2*/
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x30,0x30}
};


void ShowKeyPad(void)
{

   unsigned char DataShow[] = {0xE8, 0xAF, 0xB7, 0xE6, 0x8C ,0x89 ,0xE9, 0x94 ,0xAE ,0x2E, 0x2E, 0x2E};
   LCD_BackLight_On();
   ShowLcdOnePicture(KEYPAD);

#ifdef LIB2M
   LCD_display_UTF8Line(DataShow,12,3);
#else
   ShowCharsLine(KeyPad,0,4);
#endif

}
  


const unsigned char MagOrContectOrlessCard[20][16]=
{
	{0x40,0x42,0xCC,0x00,0x00,0x44,0x54,0x54,0x54,0x7F,0x54,0x54,0x54,0x44,0x40,0x00},
	{0x00,0x00,0x7F,0x20,0x10,0x00,0xFF,0x15,0x15,0x15,0x55,0x95,0x7F,0x00,0x00,0x00},/*"请",0*/
	{0x00,0x00,0xFE,0x12,0x12,0x12,0xF2,0x12,0x12,0x1E,0x00,0xF0,0x00,0x00,0xFF,0x00},
	{0x10,0x0E,0x01,0x3F,0x01,0x01,0xFF,0x11,0x21,0x1F,0x00,0x0F,0x40,0x80,0x7F,0x00},/*"刷",1*/
	{0x40,0x40,0x40,0x40,0x40,0x40,0xFF,0x44,0x44,0x44,0x44,0x44,0x44,0x40,0x40,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x02,0x04,0x08,0x10,0x00,0x00,0x00},/*"卡",2*/
	{0x08,0x08,0xC8,0x48,0x48,0x48,0xC8,0x08,0x08,0xFF,0x08,0x08,0x09,0xCA,0x08,0x00},
	{0x00,0x20,0x67,0x24,0x24,0x14,0x97,0x90,0x40,0x21,0x16,0x18,0x26,0x41,0xF8,0x00},/*"或",3*/
	{0x10,0x10,0x10,0xFF,0x10,0x98,0x26,0x22,0xE2,0x3A,0xA2,0x22,0x22,0x2A,0x06,0x00},
	{0x04,0x44,0x82,0x7F,0x01,0x10,0x10,0x13,0x12,0x12,0xFF,0x12,0x12,0x12,0x10,0x00},/*"挥",4*/
	{0x40,0x40,0x40,0x40,0x40,0x40,0xFF,0x44,0x44,0x44,0x44,0x44,0x44,0x40,0x40,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x02,0x04,0x08,0x10,0x00,0x00,0x00},/*"卡",5*/
	{0x08,0x08,0xC8,0x48,0x48,0x48,0xC8,0x08,0x08,0xFF,0x08,0x08,0x09,0xCA,0x08,0x00},
	{0x00,0x20,0x67,0x24,0x24,0x14,0x97,0x90,0x40,0x21,0x16,0x18,0x26,0x41,0xF8,0x00},/*"或",6*/
	{0x10,0x10,0xFF,0x10,0xB0,0x24,0x24,0xA4,0x24,0xFC,0x22,0x22,0x23,0x22,0x20,0x00},
	{0x42,0x82,0x7F,0x01,0x00,0xFF,0x49,0x48,0x40,0x7F,0x40,0x49,0x49,0xFF,0x00,0x00},/*"插",7*/
	{0x40,0x40,0x40,0x40,0x40,0x40,0xFF,0x44,0x44,0x44,0x44,0x44,0x44,0x40,0x40,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x02,0x04,0x08,0x10,0x00,0x00,0x00},/*"卡",8*/
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x30,0x30}
 };


void ShowMagOrContectOrlessCard(void)
{

  // unsigned char DataShow[] = {0xE8,0xAF,0xB7,0xE6,0x8F,0x92,0xE5,0x85,0xA5,0xE5,0x8D,0xA1,0xE7,0x89,0x87,0xE6,0x88,0x96,0xE5,0x88,0xB7,0xE7,0xA3,0x81,0xE6,0x9D,0xA1,0xE5,0x8D,0xA1,0x2E,0x2E,0x2E};
	unsigned char DataShow[] = {0xE7,0xA3 ,0x81,0xE6 ,0x9D ,0xA1 ,0x2F ,0xE9 ,0x9D ,0x9E ,0xE6 ,0x8E ,0xA5 ,0x2F ,0xE6 ,0x8E,0xA5 ,0xE8 ,0xA7 ,0xA6 ,0x2E ,0x2E ,0x2E };
   LCD_BackLight_On();
   ShowLcdOnePicture(MCCL);
#ifdef LIB2M
   LCD_display_UTF8Line(DataShow,23,3);
   //LCD_display_UTF8Line(DataShow2,2,1);
#else
   ShowCharsLine(MagOrContectOrlessCard,0,10);
#endif

}


const unsigned char MagCardOrContectCard[14][16]=
{
	{0x40,0x42,0xCC,0x00,0x00,0x44,0x54,0x54,0x54,0x7F,0x54,0x54,0x54,0x44,0x40,0x00},
	{0x00,0x00,0x7F,0x20,0x10,0x00,0xFF,0x15,0x15,0x15,0x55,0x95,0x7F,0x00,0x00,0x00},/*"请",0*/
	{0x00,0x00,0xFE,0x12,0x12,0x12,0xF2,0x12,0x12,0x1E,0x00,0xF0,0x00,0x00,0xFF,0x00},
	{0x10,0x0E,0x01,0x3F,0x01,0x01,0xFF,0x11,0x21,0x1F,0x00,0x0F,0x40,0x80,0x7F,0x00},/*"刷",1*/
	{0x40,0x40,0x40,0x40,0x40,0x40,0xFF,0x44,0x44,0x44,0x44,0x44,0x44,0x40,0x40,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x02,0x04,0x08,0x10,0x00,0x00,0x00},/*"卡",2*/
	{0x08,0x08,0xC8,0x48,0x48,0x48,0xC8,0x08,0x08,0xFF,0x08,0x08,0x09,0xCA,0x08,0x00},
	{0x00,0x20,0x67,0x24,0x24,0x14,0x97,0x90,0x40,0x21,0x16,0x18,0x26,0x41,0xF8,0x00},/*"或",3*/
	{0x10,0x10,0xFF,0x10,0xB0,0x24,0x24,0xA4,0x24,0xFC,0x22,0x22,0x23,0x22,0x20,0x00},
	{0x42,0x82,0x7F,0x01,0x00,0xFF,0x49,0x48,0x40,0x7F,0x40,0x49,0x49,0xFF,0x00,0x00},/*"插",4*/
	{0x40,0x40,0x40,0x40,0x40,0x40,0xFF,0x44,0x44,0x44,0x44,0x44,0x44,0x40,0x40,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x02,0x04,0x08,0x10,0x00,0x00,0x00},/*"卡",5*/
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x30,0x30}
};



void ShowMagCardOrContectCard(void)
{
   unsigned char DataShow[] = {0xE7 ,0xA3 ,0x81 ,0xE6 ,0x9D ,0xA1 ,0x2F ,0xE6 ,0x8E ,0xA5 ,0xE8 ,0xA7 ,0xA6 ,0x2E ,0x2E ,0x2E};
   LCD_BackLight_On();
   ShowLcdOnePicture(CCL);
#ifdef LIB2M
   LCD_display_UTF8Line(DataShow,16,3);
#else
  ShowCharsLine(MagCardOrContectCard,0,7);
#endif

}



const unsigned char ContectOrlessCard[14][16]=
{
	{0x40,0x42,0xCC,0x00,0x00,0x44,0x54,0x54,0x54,0x7F,0x54,0x54,0x54,0x44,0x40,0x00},
	{0x00,0x00,0x7F,0x20,0x10,0x00,0xFF,0x15,0x15,0x15,0x55,0x95,0x7F,0x00,0x00,0x00},/*"请",0*/
	{0x10,0x10,0xFF,0x10,0xB0,0x24,0x24,0xA4,0x24,0xFC,0x22,0x22,0x23,0x22,0x20,0x00},
	{0x42,0x82,0x7F,0x01,0x00,0xFF,0x49,0x48,0x40,0x7F,0x40,0x49,0x49,0xFF,0x00,0x00},/*"插",1*/
	{0x40,0x40,0x40,0x40,0x40,0x40,0xFF,0x44,0x44,0x44,0x44,0x44,0x44,0x40,0x40,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x02,0x04,0x08,0x10,0x00,0x00,0x00},/*"卡",2*/
	{0x08,0x08,0xC8,0x48,0x48,0x48,0xC8,0x08,0x08,0xFF,0x08,0x08,0x09,0xCA,0x08,0x00},
	{0x00,0x20,0x67,0x24,0x24,0x14,0x97,0x90,0x40,0x21,0x16,0x18,0x26,0x41,0xF8,0x00},/*"或",3*/
	{0x10,0x10,0x10,0xFF,0x10,0x98,0x26,0x22,0xE2,0x3A,0xA2,0x22,0x22,0x2A,0x06,0x00},
	{0x04,0x44,0x82,0x7F,0x01,0x10,0x10,0x13,0x12,0x12,0xFF,0x12,0x12,0x12,0x10,0x00},/*"挥",4*/
	{0x40,0x40,0x40,0x40,0x40,0x40,0xFF,0x44,0x44,0x44,0x44,0x44,0x44,0x40,0x40,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x02,0x04,0x08,0x10,0x00,0x00,0x00},/*"卡",5*/
};




void ShowContectOrlessCard(void)
{

  // unsigned char DataShow[] = {0xE8,0xAF,0xB7,0xE5,0x88,0xB7,0xE7,0xA3,0x81,0xE6,0x9D,0xA1,0xE5,0x8D,0xA1,0xE6,0x88,0x96,0xE6,0x8C,0xA5,0xE5,0x8D,0xA1,0xE6,0x88,0x96,0xE6,0x8F,0x92,0xE5,0x8D,0xA1,0x2E,0x2E};
   unsigned char DataShow[] = {0xE6 ,0x8E ,0xA5 ,0xE8 ,0xA7 ,0xA6 ,0x2F ,0xE9 ,0x9D ,0x9E ,0xE6 ,0x8E ,0xA5 ,0xE8 ,0xA7 ,0xA6 ,0x2E ,0x2E ,0x2E};
   LCD_BackLight_On();
   ShowLcdOnePicture(MC);
#ifdef LIB2M
   LCD_display_UTF8Line(DataShow,19,3);
   //LCD_display_UTF8Line(DataShow2,4,1);
#else
    ShowCharsLine(ContectOrlessCard,0,7);
#endif

}
